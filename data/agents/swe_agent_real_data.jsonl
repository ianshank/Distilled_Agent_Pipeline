{"prompt": "Implement the MangoMAS multi-agent GAN review loop with LangGraph.", "completion": "from langgraph import StateGraph, END\nfrom typing import Dict, List\nimport asyncio\n\nclass GANReviewLoop:\n    def __init__(self):\n        self.workflow = StateGraph()\n        self.setup_workflow()\n    \n    def setup_workflow(self):\n        # Add nodes for each agent\n        self.workflow.add_node('generator', self.generate_content)\n        self.workflow.add_node('pm_review', self.pm_review)\n        self.workflow.add_node('sqe_review', self.sqe_review)\n        self.workflow.add_node('architect_review', self.architect_review)\n        self.workflow.add_node('feedback_coordinator', self.evaluate_consensus)\n        \n        # Define workflow edges\n        self.workflow.set_entry_point('generator')\n        self.workflow.add_edge('generator', 'pm_review')\n        self.workflow.add_edge('pm_review', 'sqe_review')\n        self.workflow.add_edge('sqe_review', 'architect_review')\n        self.workflow.add_edge('architect_review', 'feedback_coordinator')\n        self.workflow.add_conditional_edges('feedback_coordinator', self.should_continue)\n        \n    async def generate_content(self, state: Dict) -> Dict:\n        # Generate initial content\n        state['content'] = 'Initial content'\n        state['iteration'] = 1\n        return state\n    \n    async def evaluate_consensus(self, state: Dict) -> Dict:\n        approvals = [state.get('pm_approved', False), \n                     state.get('sqe_approved', False), \n                     state.get('architect_approved', False)]\n        consensus_rate = sum(approvals) / len(approvals)\n        state['consensus_rate'] = consensus_rate\n        return state\n    \n    def should_continue(self, state: Dict) -> str:\n        if state['consensus_rate'] >= 0.75 or state['iteration'] >= 5:\n            return END\n        return 'generator'  # Continue iteration\n\n# Usage\nworkflow = GANReviewLoop().workflow.compile()\nresult = await workflow.ainvoke({'task': 'architecture_review'})"}
{"prompt": "Create a FastAPI application for the MangoMAS agent coordination system.", "completion": "from fastapi import FastAPI, HTTPException, BackgroundTasks\nfrom pydantic import BaseModel\nfrom typing import List, Dict\nimport asyncio\nimport json\n\napp = FastAPI(title='MangoMAS Agent Coordination')\n\nclass AgentRequest(BaseModel):\n    agents: List[str]\n    task: str\n    session_id: str\n\nclass AgentResponse(BaseModel):\n    session_id: str\n    status: str\n    results: Dict\n    consensus_rate: float\n\n@app.post('/api/coordinate', response_model=AgentResponse)\nasync def coordinate_agents(request: AgentRequest, background_tasks: BackgroundTasks):\n    try:\n        # Initialize agent coordination\n        session = await create_session(request.session_id)\n        \n        # Execute agent coordination in background\n        background_tasks.add_task(run_agent_coordination, request)\n        \n        return AgentResponse(\n            session_id=request.session_id,\n            status='coordinating',\n            results={},\n            consensus_rate=0.0\n        )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get('/api/session/{session_id}')\nasync def get_session_status(session_id: str):\n    session = await get_session(session_id)\n    if not session:\n        raise HTTPException(status_code=404, detail='Session not found')\n    return session\n\n@app.get('/health')\ndef health_check():\n    return {'status': 'healthy', 'timestamp': datetime.utcnow()}\n\nif __name__ == '__main__':\n    import uvicorn\n    uvicorn.run(app, host='0.0.0.0', port=8000)"}
{"prompt": "Implement the MangoMAS automated training system with AWS SageMaker integration.", "completion": "import boto3\nfrom typing import Dict, Optional\nimport asyncio\n\nclass AutomatedTrainingSystem:\n    def __init__(self):\n        self.sagemaker = boto3.client('sagemaker')\n        self.s3 = boto3.client('s3')\n        self.dynamodb = boto3.resource('dynamodb')\n    \n    async def train_agent_skill(self, config: Dict) -> Dict:\n        try:\n            # Create training job\n            training_job = await self.create_training_job(config)\n            \n            # Monitor training progress\n            await self.monitor_training_job(training_job['TrainingJobName'])\n            \n            # Evaluate results\n            evaluation = await self.evaluate_agent_skill(config)\n            \n            # Package for deployment\n            if evaluation['pass_rate'] >= config.get('threshold', 0.8):\n                await self.package_to_onnx(config)\n                await self.register_skill(config, evaluation)\n            \n            return {\n                'status': 'success',\n                'training_job': training_job['TrainingJobName'],\n                'evaluation': evaluation\n            }\n        except Exception as e:\n            return {'status': 'failed', 'error': str(e)}\n    \n    async def create_training_job(self, config: Dict) -> Dict:\n        training_params = {\n            'TrainingJobName': f\"mangomas-{config['role']}-{int(time.time())}\",\n            'AlgorithmSpecification': {\n                'TrainingImage': config['training_image'],\n                'TrainingInputMode': 'File'\n            },\n            'RoleArn': config['role_arn'],\n            'InputDataConfig': [{\n                'ChannelName': 'training',\n                'DataSource': {\n                    'S3DataSource': {\n                        'S3DataType': 'S3Prefix',\n                        'S3Uri': config['training_data_uri']\n                    }\n                }\n            }],\n            'OutputDataConfig': {\n                'S3OutputPath': config['output_uri']\n            },\n            'ResourceConfig': {\n                'InstanceType': config.get('instance_type', 'ml.m5.large'),\n                'InstanceCount': 1,\n                'VolumeSizeInGB': 30\n            },\n            'StoppingCondition': {\n                'MaxRuntimeInSeconds': config.get('max_runtime', 3600)\n            }\n        }\n        \n        return self.sagemaker.create_training_job(**training_params)\n    \n    async def evaluate_agent_skill(self, config: Dict) -> Dict:\n        # Implement multi-criteria evaluation\n        evaluation_results = {\n            'accuracy': 0.85,\n            'relevance': 0.90,\n            'completeness': 0.88,\n            'consistency': 0.92\n        }\n        \n        pass_rate = sum(evaluation_results.values()) / len(evaluation_results)\n        \n        return {\n            'pass_rate': pass_rate,\n            'metrics': evaluation_results,\n            'threshold_met': pass_rate >= config.get('threshold', 0.8)\n        }"}
{"prompt": "Build a Docker container for the MangoMAS production deployment.", "completion": "# Dockerfile for MangoMAS Production\nFROM python:3.11-slim\n\n# Set working directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    gcc \\\n    g++ \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements and install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . .\n\n# Create non-root user\nRUN useradd -m -u 1000 mangomas && chown -R mangomas:mangomas /app\nUSER mangomas\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\n# Start application\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--workers\", \"4\"]\n\n# requirements.txt\n# fastapi==0.104.1\n# uvicorn[standard]==0.24.0\n# boto3==1.34.0\n# langgraph==0.0.20\n# pydantic==2.5.0\n# redis==5.0.1\n# psycopg2-binary==2.9.9"}
{"prompt": "Create a Kubernetes deployment manifest for MangoMAS.", "completion": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mangomas\n  labels:\n    app: mangomas\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mangomas\n  template:\n    metadata:\n      labels:\n        app: mangomas\n    spec:\n      containers:\n      - name: mangomas-app\n        image: mangomas/app:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: AWS_REGION\n          value: \"us-east-1\"\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: mangomas-secrets\n              key: database-url\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: mangomas-service\nspec:\n  selector:\n    app: mangomas\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8000\n  type: LoadBalancer"}
{"prompt": "Implement a caching system for MangoMAS agent responses.", "completion": "import redis\nimport json\nimport hashlib\nfrom typing import Optional, Any\nfrom functools import wraps\n\nclass MangoMASCache:\n    def __init__(self, redis_url: str = 'redis://localhost:6379'):\n        self.redis = redis.from_url(redis_url, decode_responses=True)\n        self.default_ttl = 3600  # 1 hour\n    \n    def cache_key(self, prefix: str, data: Any) -> str:\n        \"\"\"Generate cache key from data\"\"\"\n        data_str = json.dumps(data, sort_keys=True)\n        return f\"mangomas:{prefix}:{hashlib.md5(data_str.encode()).hexdigest()}\"\n    \n    def get(self, key: str) -> Optional[Any]:\n        \"\"\"Get value from cache\"\"\"\n        try:\n            value = self.redis.get(key)\n            return json.loads(value) if value else None\n        except Exception:\n            return None\n    \n    def set(self, key: str, value: Any, ttl: int = None) -> bool:\n        \"\"\"Set value in cache\"\"\"\n        try:\n            ttl = ttl or self.default_ttl\n            return self.redis.setex(key, ttl, json.dumps(value))\n        except Exception:\n            return False\n    \n    def delete(self, key: str) -> bool:\n        \"\"\"Delete value from cache\"\"\"\n        try:\n            return bool(self.redis.delete(key))\n        except Exception:\n            return False\n\ndef cache_agent_response(ttl: int = 3600):\n    \"\"\"Decorator to cache agent responses\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            cache = MangoMASCache()\n            \n            # Generate cache key\n            cache_data = {'args': args, 'kwargs': kwargs}\n            cache_key = cache.cache_key('agent_response', cache_data)\n            \n            # Try to get from cache\n            cached_result = cache.get(cache_key)\n            if cached_result:\n                return cached_result\n            \n            # Execute function and cache result\n            result = await func(*args, **kwargs)\n            cache.set(cache_key, result, ttl)\n            \n            return result\n        return wrapper\n    return decorator\n\n# Usage example\n@cache_agent_response(ttl=1800)\nasync def get_agent_response(agent_type: str, prompt: str):\n    # Agent response logic here\n    return {'agent': agent_type, 'response': 'Sample response'}"}
{"prompt": "Create a monitoring system for MangoMAS agent performance.", "completion": "import time\nimport logging\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport boto3\n\n@dataclass\nclass AgentMetrics:\n    agent_type: str\n    response_time: float\n    success: bool\n    error_message: str = None\n    timestamp: datetime = None\n\nclass MangoMASMonitor:\n    def __init__(self):\n        self.cloudwatch = boto3.client('cloudwatch')\n        self.logger = logging.getLogger('mangomas_monitor')\n        self.metrics_buffer = []\n    \n    def record_agent_metric(self, metric: AgentMetrics):\n        \"\"\"Record agent performance metric\"\"\"\n        try:\n            # Add to buffer\n            self.metrics_buffer.append({\n                'MetricName': f'{metric.agent_type}_response_time',\n                'Value': metric.response_time,\n                'Unit': 'Milliseconds',\n                'Timestamp': metric.timestamp or datetime.utcnow(),\n                'Dimensions': [\n                    {'Name': 'AgentType', 'Value': metric.agent_type},\n                    {'Name': 'Environment', 'Value': 'production'}\n                ]\n            })\n            \n            # Flush buffer if full\n            if len(self.metrics_buffer) >= 20:\n                self.flush_metrics()\n                \n        except Exception as e:\n            self.logger.error(f'Failed to record metric: {e}')\n    \n    def flush_metrics(self):\n        \"\"\"Send metrics to CloudWatch\"\"\"\n        if not self.metrics_buffer:\n            return\n            \n        try:\n            self.cloudwatch.put_metric_data(\n                Namespace='MangoMAS/Agents',\n                MetricData=self.metrics_buffer\n            )\n            self.metrics_buffer.clear()\n        except Exception as e:\n            self.logger.error(f'Failed to flush metrics: {e}')\n    \n    def create_alarm(self, agent_type: str, threshold: float):\n        \"\"\"Create CloudWatch alarm for agent performance\"\"\"\n        try:\n            self.cloudwatch.put_metric_alarm(\n                AlarmName=f'mangomas-{agent_type}-response-time',\n                AlarmDescription=f'High response time for {agent_type} agent',\n                MetricName=f'{agent_type}_response_time',\n                Namespace='MangoMAS/Agents',\n                Statistic='Average',\n                Period=300,  # 5 minutes\n                EvaluationPeriods=2,\n                Threshold=threshold,\n                ComparisonOperator='GreaterThanThreshold',\n                Dimensions=[\n                    {'Name': 'AgentType', 'Value': agent_type}\n                ]\n            )\n        except Exception as e:\n            self.logger.error(f'Failed to create alarm: {e}')\n\ndef monitor_agent_performance(func):\n    \"\"\"Decorator to monitor agent performance\"\"\"\n    async def wrapper(*args, **kwargs):\n        monitor = MangoMASMonitor()\n        start_time = time.time()\n        \n        try:\n            result = await func(*args, **kwargs)\n            success = True\n            error_message = None\n        except Exception as e:\n            success = False\n            error_message = str(e)\n            raise\n        finally:\n            response_time = (time.time() - start_time) * 1000  # Convert to ms\n            \n            metric = AgentMetrics(\n                agent_type=func.__name__,\n                response_time=response_time,\n                success=success,\n                error_message=error_message\n            )\n            \n            monitor.record_agent_metric(metric)\n        \n        return result\n    return wrapper\n\n# Usage example\n@monitor_agent_performance\nasync def process_agent_request(agent_type: str, request: Dict):\n    # Agent processing logic here\n    await asyncio.sleep(0.1)  # Simulate processing\n    return {'status': 'success', 'agent': agent_type}"}
{"prompt": "Implement a rate limiter for MangoMAS API endpoints.", "completion": "import time\nimport asyncio\nfrom typing import Dict, Optional\nfrom fastapi import HTTPException, Request\nfrom collections import defaultdict\n\nclass RateLimiter:\n    def __init__(self, max_requests: int = 100, window_seconds: int = 60):\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests = defaultdict(list)\n    \n    def is_allowed(self, client_id: str) -> bool:\n        \"\"\"Check if request is allowed\"\"\"\n        current_time = time.time()\n        \n        # Clean old requests\n        self.requests[client_id] = [\n            req_time for req_time in self.requests[client_id]\n            if current_time - req_time < self.window_seconds\n        ]\n        \n        # Check if under limit\n        if len(self.requests[client_id]) >= self.max_requests:\n            return False\n        \n        # Add current request\n        self.requests[client_id].append(current_time)\n        return True\n    \n    def get_remaining(self, client_id: str) -> int:\n        \"\"\"Get remaining requests for client\"\"\"\n        current_time = time.time()\n        \n        # Clean old requests\n        self.requests[client_id] = [\n            req_time for req_time in self.requests[client_id]\n            if current_time - req_time < self.window_seconds\n        ]\n        \n        return max(0, self.max_requests - len(self.requests[client_id]))\n\n# Global rate limiter instance\nrate_limiter = RateLimiter(max_requests=100, window_seconds=60)\n\ndef get_client_id(request: Request) -> str:\n    \"\"\"Extract client ID from request\"\"\"\n    # Try to get from API key header\n    api_key = request.headers.get('X-API-Key')\n    if api_key:\n        return f'api_key:{api_key}'\n    \n    # Fall back to IP address\n    client_ip = request.client.host\n    return f'ip:{client_ip}'\n\ndef rate_limit_middleware(request: Request, call_next):\n    \"\"\"Rate limiting middleware\"\"\"\n    client_id = get_client_id(request)\n    \n    if not rate_limiter.is_allowed(client_id):\n        remaining = rate_limiter.get_remaining(client_id)\n        raise HTTPException(\n            status_code=429,\n            detail=f'Rate limit exceeded. Try again in {rate_limiter.window_seconds} seconds.',\n            headers={\n                'X-RateLimit-Remaining': str(remaining),\n                'X-RateLimit-Reset': str(int(time.time() + rate_limiter.window_seconds))\n            }\n        )\n    \n    response = call_next(request)\n    \n    # Add rate limit headers\n    remaining = rate_limiter.get_remaining(client_id)\n    response.headers['X-RateLimit-Remaining'] = str(remaining)\n    response.headers['X-RateLimit-Limit'] = str(rate_limiter.max_requests)\n    \n    return response\n\n# FastAPI app with rate limiting\nfrom fastapi import FastAPI\napp = FastAPI()\napp.middleware('http')(rate_limit_middleware)\n\n@app.get('/api/agents')\nasync def get_agents(request: Request):\n    return {'agents': ['SWE', 'SQE', 'Architect', 'PM']}\n\n@app.post('/api/coordinate')\nasync def coordinate_agents(request: Request):\n    return {'status': 'coordinating'}"}
{"prompt": "Create a configuration management system for MangoMAS.", "completion": "import os\nimport yaml\nimport json\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\n\nclass AgentConfig(BaseModel):\n    name: str\n    type: str\n    model: str = 'claude-3-sonnet'\n    temperature: float = 0.7\n    max_tokens: int = 4000\n    timeout: int = 30\n\nclass DatabaseConfig(BaseModel):\n    url: str\n    pool_size: int = 10\n    max_overflow: int = 20\n    echo: bool = False\n\nclass AWSConfig(BaseModel):\n    region: str = 'us-east-1'\n    access_key_id: Optional[str] = None\n    secret_access_key: Optional[str] = None\n    s3_bucket: str = 'mangomas-artifacts'\n    dynamodb_table: str = 'mangomas-sessions'\n\nclass MangoMASConfig(BaseModel):\n    agents: Dict[str, AgentConfig]\n    database: DatabaseConfig\n    aws: AWSConfig\n    environment: str = 'development'\n    debug: bool = False\n    log_level: str = 'INFO'\n\nclass ConfigManager:\n    def __init__(self, config_path: str = 'config.yaml'):\n        self.config_path = Path(config_path)\n        self.config = self.load_config()\n    \n    def load_config(self) -> MangoMASConfig:\n        \"\"\"Load configuration from file and environment\"\"\"\n        config_data = {}\n        \n        # Load from file if exists\n        if self.config_path.exists():\n            with open(self.config_path, 'r') as f:\n                config_data = yaml.safe_load(f) or {}\n        \n        # Override with environment variables\n        config_data = self.override_with_env(config_data)\n        \n        return MangoMASConfig(**config_data)\n    \n    def override_with_env(self, config: Dict) -> Dict:\n        \"\"\"Override configuration with environment variables\"\"\"\n        env_mappings = {\n            'MANGO_ENVIRONMENT': 'environment',\n            'MANGO_DEBUG': 'debug',\n            'MANGO_LOG_LEVEL': 'log_level',\n            'DATABASE_URL': 'database.url',\n            'AWS_REGION': 'aws.region',\n            'AWS_S3_BUCKET': 'aws.s3_bucket'\n        }\n        \n        for env_key, config_key in env_mappings.items():\n            env_value = os.getenv(env_key)\n            if env_value:\n                self.set_nested_value(config, config_key, env_value)\n        \n        return config\n    \n    def set_nested_value(self, config: Dict, key: str, value: Any):\n        \"\"\"Set nested configuration value\"\"\"\n        keys = key.split('.')\n        current = config\n        \n        for k in keys[:-1]:\n            if k not in current:\n                current[k] = {}\n            current = current[k]\n        \n        current[keys[-1]] = value\n    \n    def get_agent_config(self, agent_name: str) -> Optional[AgentConfig]:\n        \"\"\"Get configuration for specific agent\"\"\"\n        return self.config.agents.get(agent_name)\n    \n    def save_config(self):\n        \"\"\"Save configuration to file\"\"\"\n        config_dict = self.config.dict()\n        \n        with open(self.config_path, 'w') as f:\n            yaml.dump(config_dict, f, default_flow_style=False)\n\n# Example configuration file (config.yaml)\n\"\"\"\nenvironment: production\ndebug: false\nlog_level: INFO\n\nagents:\n  swe:\n    name: Software Engineer\n    type: development\n    model: claude-3-sonnet\n    temperature: 0.7\n    max_tokens: 4000\n    \n  sqe:\n    name: Software Quality Engineer\n    type: testing\n    model: claude-3-sonnet\n    temperature: 0.5\n    max_tokens: 3000\n    \n  architect:\n    name: Principal Architect\n    type: architecture\n    model: claude-3-sonnet\n    temperature: 0.8\n    max_tokens: 5000\n\ndatabase:\n  url: postgresql://user:pass@localhost/mangomas\n  pool_size: 20\n  max_overflow: 30\n  \naws:\n  region: us-east-1\n  s3_bucket: mangomas-artifacts\n  dynamodb_table: mangomas-sessions\n\"\"\"\n\n# Usage\nconfig_manager = ConfigManager()\nswe_config = config_manager.get_agent_config('swe')\nprint(f'SWE Agent Model: {swe_config.model}')"}
{"prompt": "Implement a logging system for MangoMAS with structured logging.", "completion": "import logging\nimport json\nimport sys\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\n\nclass MangoMASLogger:\n    def __init__(self, name: str = 'mangomas', level: str = 'INFO'):\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, level.upper()))\n        \n        # Remove existing handlers\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n        \n        # Add handlers\n        self.setup_handlers()\n    \n    def setup_handlers(self):\n        \"\"\"Setup logging handlers\"\"\"\n        # Console handler with structured format\n        console_handler = logging.StreamHandler(sys.stdout)\n        console_handler.setFormatter(self.get_formatter())\n        self.logger.addHandler(console_handler)\n        \n        # File handler for application logs\n        log_dir = Path('logs')\n        log_dir.mkdir(exist_ok=True)\n        \n        file_handler = logging.FileHandler(log_dir / 'mangomas.log')\n        file_handler.setFormatter(self.get_formatter())\n        self.logger.addHandler(file_handler)\n        \n        # Error file handler\n        error_handler = logging.FileHandler(log_dir / 'mangomas-error.log')\n        error_handler.setLevel(logging.ERROR)\n        error_handler.setFormatter(self.get_formatter())\n        self.logger.addHandler(error_handler)\n    \n    def get_formatter(self):\n        \"\"\"Get structured log formatter\"\"\"\n        return logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n    \n    def log_agent_interaction(self, agent_type: str, action: str, \n                            session_id: str, details: Dict[str, Any] = None):\n        \"\"\"Log agent interaction\"\"\"\n        log_data = {\n            'agent_type': agent_type,\n            'action': action,\n            'session_id': session_id,\n            'timestamp': datetime.utcnow().isoformat(),\n            'details': details or {}\n        }\n        \n        self.logger.info(f'Agent Interaction: {json.dumps(log_data)}')\n    \n    def log_training_event(self, agent_type: str, event_type: str, \n                          training_job_id: str, metrics: Dict[str, Any] = None):\n        \"\"\"Log training event\"\"\"\n        log_data = {\n            'agent_type': agent_type,\n            'event_type': event_type,\n            'training_job_id': training_job_id,\n            'timestamp': datetime.utcnow().isoformat(),\n            'metrics': metrics or {}\n        }\n        \n        self.logger.info(f'Training Event: {json.dumps(log_data)}')\n    \n    def log_error(self, error: Exception, context: Dict[str, Any] = None):\n        \"\"\"Log error with context\"\"\"\n        log_data = {\n            'error_type': type(error).__name__,\n            'error_message': str(error),\n            'timestamp': datetime.utcnow().isoformat(),\n            'context': context or {}\n        }\n        \n        self.logger.error(f'Error: {json.dumps(log_data)}')\n    \n    def log_performance(self, operation: str, duration: float, \n                       success: bool, details: Dict[str, Any] = None):\n        \"\"\"Log performance metrics\"\"\"\n        log_data = {\n            'operation': operation,\n            'duration_ms': round(duration * 1000, 2),\n            'success': success,\n            'timestamp': datetime.utcnow().isoformat(),\n            'details': details or {}\n        }\n        \n        self.logger.info(f'Performance: {json.dumps(log_data)}')\n\n# Usage example\nlogger = MangoMASLogger('mangomas', 'INFO')\n\n# Log agent interaction\nlogger.log_agent_interaction(\n    agent_type='SWE',\n    action='code_review',\n    session_id='session-123',\n    details={'file_count': 5, 'lines_changed': 150}\n)\n\n# Log training event\nlogger.log_training_event(\n    agent_type='SQE',\n    event_type='training_completed',\n    training_job_id='job-456',\n    metrics={'accuracy': 0.95, 'loss': 0.12}\n)\n\n# Log error\nlogger.log_error(\n    error=ValueError('Invalid configuration'),\n    context={'config_file': 'config.yaml', 'line': 25}\n)\n\n# Log performance\nlogger.log_performance(\n    operation='agent_coordination',\n    duration=0.25,\n    success=True,\n    details={'agents': 3, 'consensus_rate': 0.85}\n)"}
{"prompt": "Create a health check system for MangoMAS services.", "completion": "import asyncio\nimport aiohttp\nimport psutil\nimport redis\nfrom typing import Dict, List, Any\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n@dataclass\nclass HealthCheckResult:\n    service: str\n    status: str\n    response_time: float\n    details: Dict[str, Any]\n    timestamp: datetime\n\nclass MangoMASHealthChecker:\n    def __init__(self):\n        self.redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)\n        self.health_checks = {\n            'database': self.check_database,\n            'redis': self.check_redis,\n            'aws_services': self.check_aws_services,\n            'system_resources': self.check_system_resources,\n            'agent_endpoints': self.check_agent_endpoints\n        }\n    \n    async def check_database(self) -> HealthCheckResult:\n        \"\"\"Check database connectivity\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            # Simulate database check\n            await asyncio.sleep(0.1)\n            \n            return HealthCheckResult(\n                service='database',\n                status='healthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'connections': 5, 'pool_size': 20},\n                timestamp=datetime.utcnow()\n            )\n        except Exception as e:\n            return HealthCheckResult(\n                service='database',\n                status='unhealthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'error': str(e)},\n                timestamp=datetime.utcnow()\n            )\n    \n    async def check_redis(self) -> HealthCheckResult:\n        \"\"\"Check Redis connectivity\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            # Test Redis connection\n            self.redis_client.ping()\n            \n            return HealthCheckResult(\n                service='redis',\n                status='healthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'memory_usage': '64MB', 'connected_clients': 3},\n                timestamp=datetime.utcnow()\n            )\n        except Exception as e:\n            return HealthCheckResult(\n                service='redis',\n                status='unhealthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'error': str(e)},\n                timestamp=datetime.utcnow()\n            )\n    \n    async def check_aws_services(self) -> HealthCheckResult:\n        \"\"\"Check AWS services connectivity\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            # Simulate AWS service checks\n            await asyncio.sleep(0.2)\n            \n            return HealthCheckResult(\n                service='aws_services',\n                status='healthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={\n                    's3': 'connected',\n                    'dynamodb': 'connected',\n                    'sagemaker': 'connected'\n                },\n                timestamp=datetime.utcnow()\n            )\n        except Exception as e:\n            return HealthCheckResult(\n                service='aws_services',\n                status='unhealthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'error': str(e)},\n                timestamp=datetime.utcnow()\n            )\n    \n    async def check_system_resources(self) -> HealthCheckResult:\n        \"\"\"Check system resource usage\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            cpu_percent = psutil.cpu_percent(interval=1)\n            memory = psutil.virtual_memory()\n            disk = psutil.disk_usage('/')\n            \n            return HealthCheckResult(\n                service='system_resources',\n                status='healthy' if cpu_percent < 80 and memory.percent < 80 else 'warning',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={\n                    'cpu_percent': cpu_percent,\n                    'memory_percent': memory.percent,\n                    'disk_percent': disk.percent\n                },\n                timestamp=datetime.utcnow()\n            )\n        except Exception as e:\n            return HealthCheckResult(\n                service='system_resources',\n                status='unhealthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'error': str(e)},\n                timestamp=datetime.utcnow()\n            )\n    \n    async def check_agent_endpoints(self) -> HealthCheckResult:\n        \"\"\"Check agent endpoint health\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get('http://localhost:8000/health') as response:\n                    if response.status == 200:\n                        return HealthCheckResult(\n                            service='agent_endpoints',\n                            status='healthy',\n                            response_time=(datetime.utcnow() - start_time).total_seconds(),\n                            details={'status_code': response.status},\n                            timestamp=datetime.utcnow()\n                        )\n                    else:\n                        return HealthCheckResult(\n                            service='agent_endpoints',\n                            status='unhealthy',\n                            response_time=(datetime.utcnow() - start_time).total_seconds(),\n                            details={'status_code': response.status},\n                            timestamp=datetime.utcnow()\n                        )\n        except Exception as e:\n            return HealthCheckResult(\n                service='agent_endpoints',\n                status='unhealthy',\n                response_time=(datetime.utcnow() - start_time).total_seconds(),\n                details={'error': str(e)},\n                timestamp=datetime.utcnow()\n            )\n    \n    async def run_all_checks(self) -> Dict[str, HealthCheckResult]:\n        \"\"\"Run all health checks\"\"\"\n        results = {}\n        \n        for check_name, check_func in self.health_checks.items():\n            results[check_name] = await check_func()\n        \n        return results\n    \n    def get_overall_status(self, results: Dict[str, HealthCheckResult]) -> str:\n        \"\"\"Get overall system status\"\"\"\n        statuses = [result.status for result in results.values()]\n        \n        if 'unhealthy' in statuses:\n            return 'unhealthy'\n        elif 'warning' in statuses:\n            return 'warning'\n        else:\n            return 'healthy'\n\n# Usage example\nasync def main():\n    health_checker = MangoMASHealthChecker()\n    results = await health_checker.run_all_checks()\n    \n    overall_status = health_checker.get_overall_status(results)\n    print(f'Overall Status: {overall_status}')\n    \n    for service, result in results.items():\n        print(f'{service}: {result.status} ({result.response_time:.3f}s)')\n\n# Run health checks\n# asyncio.run(main())"} 