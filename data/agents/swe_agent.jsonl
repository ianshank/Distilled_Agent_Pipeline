{"prompt": "Write FastAPI code for a /ping endpoint.", "completion": "from fastapi import FastAPI\napp = FastAPI()\n@app.get('/ping')\ndef ping(): return {'status': 'ok'}"}
{"prompt": "Create a Python class for user authentication with JWT.", "completion": "import jwt\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nclass AuthManager:\n    def __init__(self, secret_key: str):\n        self.secret_key = secret_key\n    \n    def create_token(self, user_id: str, expires_delta: Optional[timedelta] = None):\n        if expires_delta:\n            expire = datetime.utcnow() + expires_delta\n        else:\n            expire = datetime.utcnow() + timedelta(minutes=15)\n        \n        to_encode = {\"sub\": user_id, \"exp\": expire}\n        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=\"HS256\")\n        return encoded_jwt\n    \n    def verify_token(self, token: str):\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[\"HS256\"])\n            return payload[\"sub\"]\n        except jwt.PyJWTError:\n            return None"}
{"prompt": "Implement a rate limiter decorator in Python.", "completion": "import time\nfrom functools import wraps\nfrom collections import defaultdict\n\ndef rate_limit(max_requests: int, window_seconds: int):\n    requests = defaultdict(list)\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            client_id = kwargs.get('client_id', 'default')\n            current_time = time.time()\n            \n            # Clean old requests\n            requests[client_id] = [req_time for req_time in requests[client_id] \n                                 if current_time - req_time < window_seconds]\n            \n            if len(requests[client_id]) >= max_requests:\n                raise Exception('Rate limit exceeded')\n            \n            requests[client_id].append(current_time)\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator"}
{"prompt": "Write a React component for a user profile form.", "completion": "import React, { useState } from 'react';\n\nconst UserProfileForm = ({ user, onSubmit }) => {\n  const [formData, setFormData] = useState({\n    name: user?.name || '',\n    email: user?.email || '',\n    bio: user?.bio || ''\n  });\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    onSubmit(formData);\n  };\n\n  const handleChange = (e) => {\n    setFormData({\n      ...formData,\n      [e.target.name]: e.target.value\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"max-w-md mx-auto\">\n      <div className=\"mb-4\">\n        <label className=\"block text-gray-700 text-sm font-bold mb-2\">\n          Name\n        </label>\n        <input\n          type=\"text\"\n          name=\"name\"\n          value={formData.name}\n          onChange={handleChange}\n          className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700\"\n          required\n        />\n      </div>\n      <div className=\"mb-4\">\n        <label className=\"block text-gray-700 text-sm font-bold mb-2\">\n          Email\n        </label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700\"\n          required\n        />\n      </div>\n      <div className=\"mb-6\">\n        <label className=\"block text-gray-700 text-sm font-bold mb-2\">\n          Bio\n        </label>\n        <textarea\n          name=\"bio\"\n          value={formData.bio}\n          onChange={handleChange}\n          className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700\"\n          rows=\"3\"\n        />\n      </div>\n      <button\n        type=\"submit\"\n        className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n      >\n        Save Profile\n      </button>\n    </form>\n  );\n};\n\nexport default UserProfileForm;"}
{"prompt": "Create a Dockerfile for a Node.js application.", "completion": "FROM node:18-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nUSER node\n\nCMD [\"npm\", \"start\"]"}
{"prompt": "Write a SQL query to find duplicate records.", "completion": "SELECT column1, column2, COUNT(*) as count\nFROM table_name\nGROUP BY column1, column2\nHAVING COUNT(*) > 1;"}
{"prompt": "Implement a simple cache decorator in Python.", "completion": "from functools import wraps\nimport time\n\ndef cache(ttl_seconds=300):\n    cache_data = {}\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            key = str(args) + str(sorted(kwargs.items()))\n            current_time = time.time()\n            \n            if key in cache_data:\n                result, timestamp = cache_data[key]\n                if current_time - timestamp < ttl_seconds:\n                    return result\n            \n            result = func(*args, **kwargs)\n            cache_data[key] = (result, current_time)\n            return result\n        return wrapper\n    return decorator"}
{"prompt": "Create a Kubernetes deployment manifest for a web application.", "completion": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\n  labels:\n    app: web-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n    spec:\n      containers:\n      - name: web-app\n        image: myapp:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: db-secret\n              key: url\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10"}
{"prompt": "Write a Python function to validate email addresses.", "completion": "import re\ndef validate_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\ndef validate_email_advanced(email):\n    # More comprehensive validation\n    if not email or '@' not in email:\n        return False\n    \n    local_part, domain = email.split('@', 1)\n    \n    # Check local part\n    if len(local_part) > 64 or len(local_part) == 0:\n        return False\n    \n    # Check domain\n    if len(domain) > 253 or len(domain) == 0:\n        return False\n    \n    # Check for valid characters\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))"}
{"prompt": "Implement a retry mechanism for API calls.", "completion": "import time\nimport requests\nfrom functools import wraps\n\ndef retry_on_failure(max_retries=3, delay=1, backoff=2):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            current_delay = delay\n            \n            for attempt in range(max_retries):\n                try:\n                    return func(*args, **kwargs)\n                except requests.RequestException as e:\n                    last_exception = e\n                    if attempt < max_retries - 1:\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n            \n            raise last_exception\n        return wrapper\n    return decorator\n\n@retry_on_failure(max_retries=3, delay=1)\ndef api_call(url, data=None):\n    response = requests.post(url, json=data)\n    response.raise_for_status()\n    return response.json()"}
{"prompt": "Create a logging configuration for a Python application.", "completion": "import logging\nimport logging.handlers\nimport os\n\n# Create logs directory if it doesn't exist\nos.makedirs('logs', exist_ok=True)\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        # Console handler\n        logging.StreamHandler(),\n        # File handler with rotation\n        logging.handlers.RotatingFileHandler(\n            'logs/app.log',\n            maxBytes=1024*1024,  # 1MB\n            backupCount=5\n        ),\n        # Error file handler\n        logging.handlers.RotatingFileHandler(\n            'logs/error.log',\n            maxBytes=1024*1024,\n            backupCount=5,\n            level=logging.ERROR\n        )\n    ]\n)\n\n# Create logger\nlogger = logging.getLogger(__name__)\n\n# Example usage\nlogger.info('Application started')\nlogger.error('An error occurred')\nlogger.debug('Debug information')"}
{"prompt": "Write a JavaScript function to debounce user input.", "completion": "function debounce(func, wait, immediate) {\n  let timeout;\n  \n  return function executedFunction(...args) {\n    const later = () => {\n      timeout = null;\n      if (!immediate) func(...args);\n    };\n    \n    const callNow = immediate && !timeout;\n    \n    clearTimeout(timeout);\n    \n    timeout = setTimeout(later, wait);\n    \n    if (callNow) func(...args);\n  };\n}\n\n// Example usage\nconst debouncedSearch = debounce((searchTerm) => {\n  // Perform search API call\n  console.log('Searching for:', searchTerm);\n}, 300);\n\n// Use in input event listener\ndocument.getElementById('search-input').addEventListener('input', (e) => {\n  debouncedSearch(e.target.value);\n});"}
{"prompt": "Implement a simple queue system using Redis.", "completion": "import redis\nimport json\nimport time\n\nclass RedisQueue:\n    def __init__(self, name, host='localhost', port=6379, db=0):\n        self.redis_client = redis.Redis(host=host, port=port, db=db)\n        self.name = name\n    \n    def enqueue(self, item):\n        \"\"\"Add item to the queue\"\"\"\n        self.redis_client.lpush(self.name, json.dumps(item))\n    \n    def dequeue(self):\n        \"\"\"Remove and return item from the queue\"\"\"\n        item = self.redis_client.rpop(self.name)\n        return json.loads(item) if item else None\n    \n    def peek(self):\n        \"\"\"View the next item without removing it\"\"\"\n        item = self.redis_client.lindex(self.name, -1)\n        return json.loads(item) if item else None\n    \n    def size(self):\n        \"\"\"Get the current queue size\"\"\"\n        return self.redis_client.llen(self.name)\n    \n    def clear(self):\n        \"\"\"Clear all items from the queue\"\"\"\n        self.redis_client.delete(self.name)\n\n# Example usage\nqueue = RedisQueue('task_queue')\nqueue.enqueue({'task': 'process_data', 'data': [1, 2, 3]})\ntask = queue.dequeue()\nprint(f'Processing task: {task}')"}
{"prompt": "Create a health check endpoint for a microservice.", "completion": "from flask import Flask, jsonify\nimport psutil\nimport os\nfrom datetime import datetime\n\ndef health_check():\n    \"\"\"Health check endpoint for microservice\"\"\"\n    try:\n        # Basic health indicators\n        health_status = {\n            'status': 'healthy',\n            'timestamp': datetime.utcnow().isoformat(),\n            'service': 'user-service',\n            'version': os.getenv('APP_VERSION', '1.0.0'),\n            'uptime': psutil.boot_time(),\n            'memory_usage': psutil.virtual_memory().percent,\n            'cpu_usage': psutil.cpu_percent(),\n            'disk_usage': psutil.disk_usage('/').percent\n        }\n        \n        # Check critical dependencies\n        dependencies = {\n            'database': check_database_connection(),\n            'redis': check_redis_connection(),\n            'external_api': check_external_api()\n        }\n        \n        health_status['dependencies'] = dependencies\n        \n        # Determine overall health\n        all_healthy = all(dependencies.values())\n        health_status['status'] = 'healthy' if all_healthy else 'unhealthy'\n        \n        status_code = 200 if all_healthy else 503\n        \n        return jsonify(health_status), status_code\n        \n    except Exception as e:\n        return jsonify({\n            'status': 'unhealthy',\n            'error': str(e),\n            'timestamp': datetime.utcnow().isoformat()\n        }), 503\n\ndef check_database_connection():\n    # Implement database health check\n    return True\n\ndef check_redis_connection():\n    # Implement Redis health check\n    return True\n\ndef check_external_api():\n    # Implement external API health check\n    return True"}
{"prompt": "Write a Python script to parse JSON configuration files.", "completion": "import json\nimport os\nfrom typing import Dict, Any\nfrom pathlib import Path\n\nclass ConfigManager:\n    def __init__(self, config_path: str = 'config.json'):\n        self.config_path = Path(config_path)\n        self.config = self.load_config()\n    \n    def load_config(self) -> Dict[str, Any]:\n        \"\"\"Load configuration from JSON file\"\"\"\n        if not self.config_path.exists():\n            raise FileNotFoundError(f'Config file not found: {self.config_path}')\n        \n        try:\n            with open(self.config_path, 'r') as f:\n                config = json.load(f)\n        except json.JSONDecodeError as e:\n            raise ValueError(f'Invalid JSON in config file: {e}')\n        \n        return self.validate_config(config)\n    \n    def validate_config(self, config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate required configuration fields\"\"\"\n        required_fields = ['database', 'api_key', 'environment']\n        \n        for field in required_fields:\n            if field not in config:\n                raise ValueError(f'Missing required field: {field}')\n        \n        # Validate environment\n        valid_environments = ['development', 'staging', 'production']\n        if config['environment'] not in valid_environments:\n            raise ValueError(f'Invalid environment: {config[\"environment\"]}')\n        \n        return config\n    \n    def get(self, key: str, default=None):\n        \"\"\"Get configuration value using dot notation\"\"\"\n        keys = key.split('.')\n        value = self.config\n        \n        for k in keys:\n            if isinstance(value, dict) and k in value:\n                value = value[k]\n            else:\n                return default\n        \n        return value\n    \n    def set(self, key: str, value: Any):\n        \"\"\"Set configuration value using dot notation\"\"\"\n        keys = key.split('.')\n        config = self.config\n        \n        for k in keys[:-1]:\n            if k not in config:\n                config[k] = {}\n            config = config[k]\n        \n        config[keys[-1]] = value\n    \n    def save(self):\n        \"\"\"Save configuration to file\"\"\"\n        with open(self.config_path, 'w') as f:\n            json.dump(self.config, f, indent=2, default=str)\n\n# Example usage\nconfig = ConfigManager('app_config.json')\ndb_url = config.get('database.url')\napi_key = config.get('api_key')\nconfig.set('logging.level', 'DEBUG')\nconfig.save()"}
{"prompt": "Create a simple event-driven architecture.", "completion": "from typing import Callable, Dict, List\nfrom dataclasses import dataclass\nfrom collections import defaultdict\nimport asyncio\n\n@dataclass\nclass Event:\n    name: str\n    data: dict\n    timestamp: float = None\n\nclass EventBus:\n    def __init__(self):\n        self.subscribers: Dict[str, List[Callable]] = defaultdict(list)\n    \n    def subscribe(self, event_name: str, handler: Callable):\n        \"\"\"Subscribe to an event\"\"\"\n        self.subscribers[event_name].append(handler)\n    \n    def unsubscribe(self, event_name: str, handler: Callable):\n        \"\"\"Unsubscribe from an event\"\"\"\n        if event_name in self.subscribers:\n            self.subscribers[event_name].remove(handler)\n    \n    def publish(self, event: Event):\n        \"\"\"Publish an event to all subscribers\"\"\"\n        if event.name in self.subscribers:\n            for handler in self.subscribers[event.name]:\n                try:\n                    handler(event)\n                except Exception as e:\n                    print(f'Error in event handler: {e}')\n    \n    async def publish_async(self, event: Event):\n        \"\"\"Publish an event asynchronously\"\"\"\n        if event.name in self.subscribers:\n            tasks = []\n            for handler in self.subscribers[event.name]:\n                if asyncio.iscoroutinefunction(handler):\n                    tasks.append(handler(event))\n                else:\n                    # Run synchronous handlers in thread pool\n                    loop = asyncio.get_event_loop()\n                    tasks.append(loop.run_in_executor(None, handler, event))\n            \n            if tasks:\n                await asyncio.gather(*tasks, return_exceptions=True)\n\n# Example usage\nevent_bus = EventBus()\n\ndef user_created_handler(event):\n    print(f'User created: {event.data}')\n\ndef email_handler(event):\n    print(f'Sending welcome email to: {event.data[\"email\"]}')\n\nevent_bus.subscribe('user.created', user_created_handler)\nevent_bus.subscribe('user.created', email_handler)\n\nevent = Event('user.created', {'user_id': 123, 'email': 'test@example.com'})\nevent_bus.publish(event)"}
{"prompt": "Write a function to generate secure random passwords.", "completion": "import secrets\nimport string\n\ndef generate_password(length=12, include_symbols=True, include_numbers=True, include_uppercase=True):\n    \"\"\"Generate a secure random password\"\"\"\n    characters = string.ascii_lowercase\n    \n    if include_uppercase:\n        characters += string.ascii_uppercase\n    if include_numbers:\n        characters += string.digits\n    if include_symbols:\n        characters += string.punctuation\n    \n    # Generate password\n    password = ''.join(secrets.choice(characters) for _ in range(length))\n    \n    # Ensure at least one of each required character type\n    if include_uppercase and not any(c in string.ascii_uppercase for c in password):\n        password += secrets.choice(string.ascii_uppercase)\n    if include_numbers and not any(c in string.digits for c in password):\n        password += secrets.choice(string.digits)\n    if include_symbols and not any(c in string.punctuation for c in password):\n        password += secrets.choice(string.punctuation)\n    \n    return password\n\ndef generate_strong_password(length=16):\n    \"\"\"Generate a strong password with all character types\"\"\"\n    return generate_password(\n        length=length,\n        include_symbols=True,\n        include_numbers=True,\n        include_uppercase=True\n    )\n\n# Example usage\npassword = generate_strong_password()\nprint(f'Generated password: {password}')"}
{"prompt": "Implement a simple dependency injection container.", "completion": "from typing import Dict, Type, Any, Callable\n\nclass Container:\n    def __init__(self):\n        self.services: Dict[str, Any] = {}\n        self.singletons: Dict[str, Any] = {}\n        self.factories: Dict[str, Callable] = {}\n    \n    def register(self, name: str, factory: Callable, singleton=False):\n        \"\"\"Register a service with the container\"\"\"\n        if singleton:\n            self.factories[name] = factory\n        else:\n            self.factories[name] = factory\n    \n    def register_singleton(self, name: str, instance: Any):\n        \"\"\"Register a singleton instance\"\"\"\n        self.singletons[name] = instance\n    \n    def resolve(self, name: str):\n        \"\"\"Resolve a service from the container\"\"\"\n        # Check if it's a singleton instance\n        if name in self.singletons:\n            return self.singletons[name]\n        \n        # Check if it's a factory\n        if name in self.factories:\n            instance = self.factories[name]()\n            # Cache singleton instances\n            if name in self.factories:\n                self.singletons[name] = instance\n            return instance\n        \n        raise KeyError(f'Service {name} not found')\n    \n    def has(self, name: str) -> bool:\n        \"\"\"Check if a service is registered\"\"\"\n        return name in self.singletons or name in self.factories\n\n# Example usage\nclass Database:\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n    \n    def connect(self):\n        print(f'Connecting to {self.connection_string}')\n\nclass UserService:\n    def __init__(self, database):\n        self.database = database\n    \n    def get_user(self, user_id):\n        self.database.connect()\n        return {'id': user_id, 'name': 'John Doe'}\n\n# Setup container\ncontainer = Container()\ncontainer.register('database', lambda: Database('postgresql://localhost/mydb'), singleton=True)\ncontainer.register('user_service', lambda: UserService(container.resolve('database')))\n\n# Use services\nuser_service = container.resolve('user_service')\nuser = user_service.get_user(123)\nprint(user)"}
{"prompt": "Create a Python script to monitor disk usage.", "completion": "import psutil\nimport os\nfrom datetime import datetime\nimport time\n\ndef monitor_disk_usage(path='/'):\n    \"\"\"Monitor disk usage for a given path\"\"\"\n    try:\n        disk_usage = psutil.disk_usage(path)\n        \n        # Calculate usage statistics\n        total_gb = disk_usage.total / (1024**3)\n        used_gb = disk_usage.used / (1024**3)\n        free_gb = disk_usage.free / (1024**3)\n        usage_percent = disk_usage.percent\n        \n        print(f'Disk Usage for {path}:')\n        print(f'Total: {total_gb:.2f} GB')\n        print(f'Used: {used_gb:.2f} GB')\n        print(f'Free: {free_gb:.2f} GB')\n        print(f'Usage: {usage_percent:.1f}%')\n        \n        # Alert if usage is high\n        if usage_percent > 90:\n            print('ðŸš¨ WARNING: Disk usage is above 90%!')\n        elif usage_percent > 80:\n            print('âš ï¸  WARNING: Disk usage is above 80%!')\n        \n        return {\n            'path': path,\n            'total_gb': total_gb,\n            'used_gb': used_gb,\n            'free_gb': free_gb,\n            'usage_percent': usage_percent,\n            'timestamp': datetime.now().isoformat()\n        }\n        \n    except Exception as e:\n        print(f'Error monitoring disk usage: {e}')\n        return None\n\ndef monitor_all_disks():\n    \"\"\"Monitor all mounted disks\"\"\"\n    partitions = psutil.disk_partitions()\n    \n    for partition in partitions:\n        if partition.device.startswith('/dev/'):  # Unix-like systems\n            print(f'\\n--- {partition.device} ---')\n            monitor_disk_usage(partition.mountpoint)\n\ndef continuous_monitoring(interval=60):\n    \"\"\"Continuously monitor disk usage\"\"\"\n    print(f'Starting continuous disk monitoring (interval: {interval}s)')\n    \n    try:\n        while True:\n            print(f'\\n=== {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")} ===')\n            monitor_all_disks()\n            time.sleep(interval)\n    except KeyboardInterrupt:\n        print('\\nMonitoring stopped by user')\n\n# Example usage\nif __name__ == '__main__':\n    # Single check\n    monitor_disk_usage('/')\n    \n    # Monitor all disks\n    # monitor_all_disks()\n    \n    # Continuous monitoring\n    # continuous_monitoring(300)  # Check every 5 minutes"}
{"prompt": "Implement a simple circuit breaker pattern.", "completion": "import time\nfrom enum import Enum\nfrom typing import Callable, Any\n\nclass CircuitState(Enum):\n    CLOSED = 'closed'\n    OPEN = 'open'\n    HALF_OPEN = 'half_open'\n\nclass CircuitBreaker:\n    def __init__(self, failure_threshold=5, recovery_timeout=60, expected_exception=Exception):\n        self.failure_threshold = failure_threshold\n        self.recovery_timeout = recovery_timeout\n        self.expected_exception = expected_exception\n        \n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = CircuitState.CLOSED\n    \n    def call(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"Execute function with circuit breaker protection\"\"\"\n        if self.state == CircuitState.OPEN:\n            if time.time() - self.last_failure_time > self.recovery_timeout:\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception('Circuit breaker is OPEN')\n        \n        try:\n            result = func(*args, **kwargs)\n            self.on_success()\n            return result\n        except self.expected_exception as e:\n            self.on_failure()\n            raise e\n    \n    def on_success(self):\n        \"\"\"Handle successful execution\"\"\"\n        self.failure_count = 0\n        self.state = CircuitState.CLOSED\n    \n    def on_failure(self):\n        \"\"\"Handle failed execution\"\"\"\n        self.failure_count += 1\n        self.last_failure_time = time.time()\n        \n        if self.failure_count >= self.failure_threshold:\n            self.state = CircuitState.OPEN\n    \n    def get_state(self) -> CircuitState:\n        \"\"\"Get current circuit breaker state\"\"\"\n        return self.state\n    \n    def reset(self):\n        \"\"\"Reset circuit breaker to closed state\"\"\"\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = CircuitState.CLOSED\n\n# Example usage\ndef unreliable_api_call():\n    import random\n    if random.random() < 0.7:  # 70% failure rate\n        raise Exception('API call failed')\n    return 'Success'\n\n# Create circuit breaker\ncircuit_breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=30)\n\n# Use circuit breaker\nfor i in range(10):\n    try:\n        result = circuit_breaker.call(unreliable_api_call)\n        print(f'Call {i+1}: {result}')\n    except Exception as e:\n        print(f'Call {i+1}: {e} (State: {circuit_breaker.get_state().value})')\n    time.sleep(1)"}
{"prompt": "Create a simple configuration management system.", "completion": "import os\nimport yaml\nimport json\nfrom typing import Any, Dict, Optional\nfrom pathlib import Path\n\nclass ConfigManager:\n    def __init__(self, config_path: str = 'config.yaml', env_prefix: str = 'APP_'):\n        self.config_path = Path(config_path)\n        self.env_prefix = env_prefix\n        self.config = self.load_config()\n    \n    def load_config(self) -> Dict[str, Any]:\n        \"\"\"Load configuration from file and environment variables\"\"\"\n        config = {}\n        \n        # Load from file if it exists\n        if self.config_path.exists():\n            with open(self.config_path, 'r') as f:\n                if self.config_path.suffix == '.yaml' or self.config_path.suffix == '.yml':\n                    config = yaml.safe_load(f) or {}\n                elif self.config_path.suffix == '.json':\n                    config = json.load(f)\n        \n        # Override with environment variables\n        config = self.override_with_env(config)\n        \n        return config\n    \n    def override_with_env(self, config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Override configuration with environment variables\"\"\"\n        for key, value in os.environ.items():\n            if key.startswith(self.env_prefix):\n                config_key = key[len(self.env_prefix):].lower()\n                config[config_key] = self.parse_env_value(value)\n        \n        return config\n    \n    def parse_env_value(self, value: str) -> Any:\n        \"\"\"Parse environment variable value\"\"\"\n        # Try to parse as different types\n        if value.lower() in ('true', 'false'):\n            return value.lower() == 'true'\n        try:\n            return int(value)\n        except ValueError:\n            try:\n                return float(value)\n            except ValueError:\n                return value\n    \n    def get(self, key: str, default=None):\n        \"\"\"Get configuration value using dot notation\"\"\"\n        keys = key.split('.')\n        value = self.config\n        \n        for k in keys:\n            if isinstance(value, dict) and k in value:\n                value = value[k]\n            else:\n                return default\n        \n        return value\n    \n    def set(self, key: str, value: Any):\n        \"\"\"Set configuration value using dot notation\"\"\"\n        keys = key.split('.')\n        config = self.config\n        \n        for k in keys[:-1]:\n            if k not in config:\n                config[k] = {}\n            config = config[k]\n        \n        config[keys[-1]] = value\n    \n    def save(self, format: str = 'yaml'):\n        \"\"\"Save configuration to file\"\"\"\n        self.config_path.parent.mkdir(parents=True, exist_ok=True)\n        \n        with open(self.config_path, 'w') as f:\n            if format == 'yaml' or self.config_path.suffix in ('.yaml', '.yml'):\n                yaml.dump(self.config, f, default_flow_style=False)\n            elif format == 'json' or self.config_path.suffix == '.json':\n                json.dump(self.config, f, indent=2)\n    \n    def reload(self):\n        \"\"\"Reload configuration from file and environment\"\"\"\n        self.config = self.load_config()\n\n# Example usage\nconfig = ConfigManager('app_config.yaml')\n\n# Set some values\nconfig.set('database.host', 'localhost')\nconfig.set('database.port', 5432)\nconfig.set('app.debug', True)\n\n# Save configuration\nconfig.save()\n\n# Get values\ndb_host = config.get('database.host')\ndb_port = config.get('database.port')\ndebug = config.get('app.debug')\n\nprint(f'Database: {db_host}:{db_port}')\nprint(f'Debug mode: {debug}')"} 